#include "bls.h"
#include "test_point.hpp"

using namespace std;
using namespace bn;

/* Function: hash_msg
 * hash message onto curve: h = H(M) \in G_1
 * @param {char*} msg
 * @return {Ec1} point in G_1
 */
Ec1 hash_msg(const char *msg) {
  // TODO, swap out. This is a dummy hash function
  // All code in here is duplicate boilerplate to generate a point on the curve
  // You can delete all of this.
  // Referred to: http://www.cplusplus.com/reference/string/stoll/
  // Add a terminating condition suppose we don't find anything after count blows up
  long long x, y;
  string::size_type sz;
  int count = 0;
  bool squareRootExists = false;
  while(!squareRootExists){
    string xString = sha256(msg);
    x = stoll(xString, &sz, 0); //stoll(xString, nullptr, 16); (this line is buggy)
    x += count << ((int)floor(log2(x)) + 1); //prepending count
    y = sqrt(x); //TODO: change this into the code using mod p sqrt
    if(y * y == x) {
      squareRootExists = true;
      //return Ec1(x, y);
    }
    ++count;
    /*
    cout << "sizeof(xString): " << sizeof(xString) << endl;
    cout << "xString: " << xString << endl;
    cout << "x: " << x << endl;
    cout << "sqrt(x): " << sqrt(x) << endl;
    */
  }

  //cout << "output: " << output << endl;

  bn::CurveParam cp = bn::CurveFp254BNb;
  Param::init(cp);

  const Point& pt = selectPoint(cp);

  // get g2
  const Ec2 g2(
    Fp2(Fp(pt.g2.aa), Fp(pt.g2.ab)),
    Fp2(Fp(pt.g2.ba), Fp(pt.g2.bb))
  );

  // get g1
  const Ec1 g1(pt.g1.a, pt.g1.b);

  const mie::Vuint rand_msg_mult(rand());
  Ec1 hashed_msg_point = g1 * rand_msg_mult;
  return hashed_msg_point;
}


/*
 * @param {char* } rand_seed, string representation of 256 bit int
 * @return {Ec2}  public key point
 * public_key = g2 ^ secret_key
 */
Ec2 gen_key(char *rand_seed) {

  bn::CurveParam cp = bn::CurveFp254BNb;
  Param::init(cp);

  const Point& pt = selectPoint(cp);

  // get g2
  const Ec2 g2(
    Fp2(Fp(pt.g2.aa), Fp(pt.g2.ab)),
    Fp2(Fp(pt.g2.ba), Fp(pt.g2.bb))
  );

  // get g1
  const Ec1 g1(pt.g1.a, pt.g1.b);

  // convert seed into Variable sized uint
  // TODO, test that this conversion works properly
  const mie::Vuint secret_key(rand_seed);

  // Multiply generator by pk
  Ec2 public_key_point = g2 * secret_key;

  const char* msg = "my msg";
  Ec1 hashed_msg_point = hash_msg(msg);
  Ec1 signed_msg = hashed_msg_point * secret_key;

  // TEST VALIDATION
  Fp12 pairing_1; // e(g, H(m)^pk)
  Fp12 pairing_2; // e(g^pk, H(m))

  opt_atePairing(pairing_1, g2, signed_msg);
  opt_atePairing(pairing_2, public_key_point, hashed_msg_point);

  if(pairing_1 == pairing_2) {
    printf("It's working");
  } else {
    printf("NOT working");
  }

  // TODO, determine data structure to return
  // Should probably return struct or array
  // Perhaps this method should just return the
  // pubkey and should take as input the private key
  // so that can be generated by whatever means possible
  return public_key_point;
}


/* Function: aggregate_sigs()
 * Multiply signatures together to create aggregate signature
 * @param {std::vector<Ec1>*} sigs
 * @returns {Ec1} aggregate signature
 */
Ec1 aggregate_sigs(const std::vector<Ec1>& sigs) {
  // multiply all signatures together
  Ec1 sig_product = sigs[0];

  for(size_t i=1; i < sigs.size(); i++) {
    // TODO, should this be addition here? Ask Dan
    sig_product = sig_product + sigs[i];
  }
  return sig_product;
}

// TODO: requires hash function

bool verify_sig(char* pubkey, char* msg, Ec1 sig) {
  Fp12 e;

  // hash msg
  bool sig_valid;

  // check pairing equality
  // does equality check need to be special?
  // e(g, H(m)^alpha) == e(g^alpha (pubkey), H(m))


  return sig_valid;
}

/* Function: verify_agg_sig()
 * Verify aggregate signature for n pubkey, msg pairs
 * Each message must be distinct
 *
 */
// bool verify_agg_sig(char* pubkeys[], vector<char*>* msgs, Ec1 sig) {

// }



int main() {

    // Get random number x in Zp
    // Exponentiate g2 by x
    // Return keypair
    // Generate random 256 bit string
    char *seed = "15267802884793550383558706039165621050290089775961208824303765753922461897946";
    gen_key(seed);
    return 0;
}

// TODO

// -Distributed Key Generation
// -Simple BLS Sig
// -Again look at data types here
// -Threshold Signatures
// -Blind Signatures
// - Aggregate signatures
// -Signing Function