#include "bls.h"
#include "test_point.hpp"

using namespace std;
using namespace bn;

/* Function: pow_p
 * power mod p
 */
static const mie::Vuint pow_p(const mie::Vuint val, const mie::Vuint power){
  if(power == 0) return 1;
  if(power == 1) return val;
  const mie::Vuint result_sqrt_floor = pow_p(val, power/2);
  return (((result_sqrt_floor * result_sqrt_floor) % Param::p) * pow_p(val, power % 2)) % Param::p;
}

/* Function: sqrt_p
 * sqrt mod p
 */
static const mie::Vuint sqrt_p(const mie::Vuint val, bool *valid){
  if(Param::p % 4 == 3){
    const mie::Vuint power = (Param::p + 1)/4;
    const mie::Vuint result = pow_p(val, power);
    *valid = true;
    return result;
  } else { //TODO (for the case of p%4 == 1, doesn't apply to our case for now)
    *valid = true;
    return 1;
  }
}

/* Function: hash_msg
 * hash message onto curve: h = H(M) \in G_1
 * @param {char*} msg
 * @return {Ec1} point in G_1
 */
Ec1 hash_msg(const char *msg) {
  bn::CurveParam cp = bn::CurveFp254BNb;
  Param::init(cp);
  Ec1 hashed_msg_point;
  int count = 0;
  bool squareRootExists = false;
  while(!squareRootExists){
    string xString = "0x" + sha256(msg);
    const mie::Vuint x(xString);
    //TODO: prepend (why do we even need this in the case of Param::p % 4 == 3?) (Ask Dan)
    const mie::Vuint x3plusb = ((((x * x) % Param::p) * x) % Param::p + cp.b) % Param::p;
    const mie::Vuint y =  sqrt_p(x3plusb, &squareRootExists);
    if(squareRootExists){
      Fp x_mod_p(x % Param::p);
      Fp y_mod_p(y % Param::p);
      const Ec1 result(x_mod_p, y_mod_p);
      return result;
    } else {
      ++count; //To prepend later
    }
  }
  /*Dummy code just to make the function complete*/
  const Point& pt = selectPoint(cp);
  const Ec1 g1(pt.g1.a, pt.g1.b); // get g1
  const mie::Vuint rand_msg_mult(rand());
  hashed_msg_point = g1 * rand_msg_mult;
  return hashed_msg_point;
}


/*
 * @param {char* } rand_seed, string representation of 256 bit int
 * @return {Ec2}  public key point
 * public_key = g2 ^ secret_key
 */
Ec2 gen_key(char *rand_seed) {

  bn::CurveParam cp = bn::CurveFp254BNb;
  Param::init(cp);

  const Point& pt = selectPoint(cp);

  // get g2
  const Ec2 g2(
    Fp2(Fp(pt.g2.aa), Fp(pt.g2.ab)),
    Fp2(Fp(pt.g2.ba), Fp(pt.g2.bb))
  );

  // get g1
  const Ec1 g1(pt.g1.a, pt.g1.b);

  // convert seed into Variable sized uint
  // TODO, test that this conversion works properly
  const mie::Vuint secret_key(rand_seed);

  // Multiply generator by pk
  Ec2 public_key_point = g2 * secret_key;

  const char* msg = "my msg";
  Ec1 hashed_msg_point = hash_msg(msg);
  Ec1 signed_msg = hashed_msg_point * secret_key;

  // TEST VALIDATION
  Fp12 pairing_1; // e(g, H(m)^pk)
  Fp12 pairing_2; // e(g^pk, H(m))

  opt_atePairing(pairing_1, g2, signed_msg);
  opt_atePairing(pairing_2, public_key_point, hashed_msg_point);

  if(pairing_1 == pairing_2) {
    printf("It's working");
  } else {
    printf("NOT working");
  }

  // TODO, determine data structure to return
  // Should probably return struct or array
  // Perhaps this method should just return the
  // pubkey and should take as input the private key
  // so that can be generated by whatever means possible
  return public_key_point;
}


/* Function: aggregate_sigs()
 * Multiply signatures together to create aggregate signature
 * @param {std::vector<Ec1>*} sigs
 * @returns {Ec1} aggregate signature
 */
Ec1 aggregate_sigs(const std::vector<Ec1>& sigs) {
  // multiply all signatures together
  Ec1 sig_product = sigs[0];

  for(size_t i=1; i < sigs.size(); i++) {
    // TODO, should this be addition here? Ask Dan
    sig_product = sig_product + sigs[i];
  }
  return sig_product;
}

// TODO: requires hash function

bool verify_sig(char* pubkey, char* msg, Ec1 sig) {
  Fp12 e;

  // hash msg
  bool sig_valid;

  // check pairing equality
  // does equality check need to be special?
  // e(g, H(m)^alpha) == e(g^alpha (pubkey), H(m))


  return sig_valid;
}

/* Function: verify_agg_sig()
 * Verify aggregate signature for n pubkey, msg pairs
 * Each message must be distinct
 *
 */
// bool verify_agg_sig(char* pubkeys[], vector<char*>* msgs, Ec1 sig) {

// }



int main() {

    // Get random number x in Zp
    // Exponentiate g2 by x
    // Return keypair
    // Generate random 256 bit string
    char *seed = "15267802884793550383558706039165621050290089775961208824303765753922461897946";
    gen_key(seed);
    return 0;
}

// TODO

// -Distributed Key Generation
// -Simple BLS Sig
// -Again look at data types here
// -Threshold Signatures
// -Blind Signatures
// - Aggregate signatures
// -Signing Function