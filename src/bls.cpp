#include "bls.h"
#include "test_point.hpp"

using namespace std;
using namespace bn;

// !!!!!XXXXXX
// Normal Key Generation
// !!!!!!!!!!!!!
// Also not proper data type, should be larger
// Not sure if need to create own type or use pre-existing
Ec2 gen_key() {
  int rand_num;

  bn::CurveParam cp = bn::CurveFp254BNb;
  Param::init(cp);

  const Point& pt = selectPoint(cp);
  const Ec2 g2(
    Fp2(Fp(pt.g2.aa), Fp(pt.g2.ab)),
    Fp2(Fp(pt.g2.ba), Fp(pt.g2.bb))
  );

  const Ec1 g1(pt.g1.a, pt.g1.b);

  // verify("g1 is on EC", g1.isValid(), true);
  // verify("g2 is on twist EC", g2.isValid(), true);


  //!!!! TODO !!!, this is just a placeholder
  // GET RID OF THIS ASAP
  rand_num = rand();
  // !!!!!!!!

  // convert random number into Variable sized uint
  const mie::Vuint private_key(rand_num);

  // Multiply generator by pk
  Ec2 pk_point = g2 * private_key;

  // TEST SIGNING

  const mie::Vuint rand_msg_mult(rand());
  Ec1 hashed_msg_point = g1 * rand_msg_mult;

  Ec1 signed_msg = hashed_msg_point * private_key;

  // TEST VALIDATION
  
  Fp12 pairing_1; // e(g, H(m)^pk)
  Fp12 pairing_2; // e(g^pk, H(m))

  opt_atePairing(pairing_1, g2, signed_msg);
  opt_atePairing(pairing_2, pk_point, hashed_msg_point);

  if(pairing_1 == pairing_2) {
    printf("It's working");
  } else {
    printf("NOT working");
  }

  
  // TODO, determine data structure to return
  // Should probably return struct or array
  // Perhaps this method should just return the 
  // pubkey and should take as input the private key
  // so that can be generated by whatever means possible
  return pk_point;
}


/* Function: get_pubkey
 * given private key, calculates point of public key in G2
 * public_key = g2 ^ private_key
 * @param {char*} private_key, String versiono of integer representing private key in Zp (e.g. "32423413242")
 * @returns {Ec2} public_key, Point in G2
 */
Ec2 get_pubkey(char *private_key) {
  // check that private_key in Zp

  // initialize curve
  bn::CurveParam cp = bn::CurveFp254BNb;
  Param::init(cp);

  // create generator g2
  // TODO: check that this generator is the correct one to use
  const Point& pt = selectPoint(cp);
  const Ec2 g2(
    Fp2(Fp(pt.g2.aa), Fp(pt.g2.ab)),
    Fp2(Fp(pt.g2.ba), Fp(pt.g2.bb))
  );

  // convert private_key into variable-sized uint
  const mie::Vuint private_key(rand_num);

  // Multiply generator by private_key value
  // to calculate public key
  Ec2 public_key = g2 * private_key;

  return public_key;
}

// !!!!!!!!!!!!!!

// Distributed Key Generation

// Simple BLS Sig
// Again look at data types here
// int bls_sign(char* msg) {
//   char* signed_msg;

  // hash message onto curve
  // exponentiate

//   return signed_msg;
// }

// Threshold Signatures


// Blind Signatures


// Signing Function


// Verify

bool bls_verify(int pubkey, char* msg, int sig) {
  Fp12 e;

  // hash msg
  bool sig_valid;
  
  // check pairing equality
  // does equality check need to be special?
  // e(g, H(m)^alpha) == e(g^alpha (pubkey), H(m)) 


  return sig_valid;

}



int main() {

    // Get random number x in Zp
    // Exponentiate g2 by x
    // Return keypair
    gen_key();
    return 0;
}
